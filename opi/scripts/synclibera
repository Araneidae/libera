#!/usr/bin/env python2.4

import sys
import os.path
import optparse
import datetime

from pkg_resources import require
require("cothread==1.5")
# sys.path.append('/home/mga83/epics/cothread/build/lib.linux-i686-2.4')
from cothread import catools, Sleep



# We have three separate synchronisation groups: LB, BS and TS.

LB_BPMS = \
    ['LB-DI-EBPM-%02d' % (num + 1) for num in range(7)] + \
    ['BR%02dC-DI-EBPM-%02d' %
        (cell + 1, 1 + (5*cell + (cell+1)//2 + num - 3) % 22)
        for cell in range(4)
        for num in range(5 + (cell+1) % 2)]

BS_BPMS = \
    ['BS-DI-EBPM-%02d' % (num + 1) for num in range(7)]

SR_BPMS = \
    ['SR%02dC-DI-EBPM-%02d' % (cell + 1, num + 1)
        for cell in range(24) for num in range(7)] + \
    ['SR21C-DI-EBPM-08']

TS_BPMS = ['TS-DI-EBPM-%02d' % (num + 1) for num in range(7)]

LB_EVRS = \
    ['LI-DI-EVR-01'] + \
    ['BR%02dC-DI-EVR-01' % (num+1) for num in range(4)]

BS_EVRS = \
    ['BS-DI-EVR-01']

SR_EVRS = \
    ['SR%02dC-DI-EVR-01' % (num+1) for num in range(24)]

TS_EVRS = ['TS-DI-EVR-01']

SR_TRIGGER = 'LI-TI-MTGEN-01:SR-DI'
LB_TRIG = 'LI-TI-MTGEN-01:LB-DI-MODE'
BS_TRIG = 'LI-TI-MTGEN-01:BS-DI-MODE'


def PVs(bases, pv):
    return ['%s:%s' % (base, pv) for base in bases]

def caput(pvs, value):
    catools.caput(pvs, value, repeat_value = True, timeout = 5)

def caget(pvs, datatype=None, throw=True, format=catools.FORMAT_RAW):
    return catools.caget(pvs,
        datatype = datatype, timeout = 5, throw = throw, format = format)


def CheckReadbacks(bpms, pv, expected):
    for bpm, s in zip(bpms, caget(PVs(bpms, pv), datatype = type(expected))):
        if s != expected:
            print bpm, s, '-- should be:', expected


def GetActivePVs(iocs, pv):
    enabled_list = caget(PVs(iocs, pv), throw = False)
    result = []
    for ioc, enabled in zip(iocs, enabled_list):
        if enabled.ok:
            result.append(ioc)
        else:
            print ' ', ioc, 'not responding'
    return result

def GetActiveBpms(bpms):
    print 'Checking active BPMs'
    return GetActivePVs(bpms, 'CF:ENABLED_S')

def GetActiveEvrs(evrs):
    print 'Checking active EVRs'
    return GetActivePVs(evrs, 'TRIG:MODE')

def GetFeedbackBpms(AllBpms):
    print 'Checking BPMs for FF support'
    return GetActivePVs(AllBpms, 'FF:VERSION')



def GlobalSystemTrigger():
    caput([SR_TRIGGER], 1)
    caput([SR_TRIGGER], 0)

def LabSystemTrigger():
    caput(['TS-DI-EVR-01:TS-RESET.OUT2'], 1)

class GlobalMachineTrigger:
    def __init__(self, triggers):
        self.triggers = triggers
    def Disable(self):
        caput(self.triggers, 'Off')
    def Enable(self):
        caput(self.triggers, 'Every shot')

class LabMachineTrigger:
    def Disable(self):
        caput(['TS-DI-EVR-01:TRIG:MODE'], 'Synchronised')
    def Enable(self):
        caput(['TS-DI-EVR-01:TRIG:MODE'], 'Normal')
    

def SynchroniseSystemClocks(bpms, evrs, trigger):
    # First put all EVRs into Synchronised mode
    print 'Synchronising system clocks'
    print '  Switching to Synchronised mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    CheckReadbacks(evrs, 'TRIG:MODE', 'Synchronised')
    Sleep(5)
    
    print '  Enabling SC trigger'
    caput(PVs(bpms, 'CK:SC_SYNC_S'), 0)
    Sleep(2)
    CheckReadbacks(bpms, 'CK:SC_SYNC', 'Waiting Trigger')
    
    print '  Triggering SC synchronisation'
    trigger()
    Sleep(5)
    
    print '  Restoring Normal mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')

    

def SynchroniseMachineClocks(bpms, triggers):
    print 'Synchronising machine clocks'

    # First disable all the triggers.
    print '  Disabling events'
    triggers.Disable()
    Sleep(5)
    
    print '  Arming MC trigger'
    caput(PVs(bpms, 'CK:MC_SYNC_S'), 0)
    Sleep(5)
    CheckReadbacks(bpms, 'CK:MC_SYNC', 'Waiting Trigger')
    
    print '  Triggering MC synchronisation'
    triggers.Enable()
    Sleep(2)


def FindCommonValue(values):
    d = {}
    for value in values:
        if value not in d:
            d[value] = 0
        d[value] += 1
        
    c = 0
    for value, count in d.iteritems():
        if count > c:
            v = value
            c = count
    return v
        

def AnalyseTimes(location, bpms, times, margin = 0):
    common_time = FindCommonValue(times)
    print '%s:' % location, common_time
    
    good_bpms = []
    bad_bpms = []
    for bpm, time in zip(bpms, times):
        if abs(time - common_time) > margin:
            print ' ', bpm, time
            bad_bpms.append(bpm)
        else:
            good_bpms.append(bpm)
    return good_bpms, bad_bpms

        

def CheckSystemClocks(bpms, evrs, trigger):
    print 'Checking system clocks'
    print '  Switching to Synchronised mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    caput(PVs(bpms, 'CK:TIMESTAMP_S'), 'System time')
    Sleep(5)
    print '  Triggering'
    trigger()
    Sleep(3)
    mcls = caget(PVs(bpms, 'CK:MCL'), format = catools.FORMAT_TIME)
    print '  Restoring Normal mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')
    
    good_bpms, bad_bpms = AnalyseTimes(
        'Time', bpms, [mcl.datetime for mcl in mcls],
        margin = datetime.timedelta(0))
#     # Put all bad bpms back to NTP time, leave the good ones with system
#     # time.
#     caput(PVs(bad_bpms, 'CK:TIMESTAMP_S'), 'NTP time')
    # Alas we still can't enable System time for timestamps, as SC
    # timestamping remains rather unreliable: so put everything back to NTP
    # time for now.
    caput(PVs(bpms, 'CK:TIMESTAMP_S'), 'NTP time')

    
def CheckMachineClocks(lb_bpms, bs_bpms, sr_bpms, ts_bpms, evrs, trigger):
    print 'Checking machine clocks'
    print '  Disabling events'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    Sleep(5)
    print '  Triggering'
    trigger()
    Sleep(5)

    for location, bpms in (
            ('LB', lb_bpms), ('BS', bs_bpms), ('SR', sr_bpms),
            ('TS', ts_bpms)):
        if bpms:
            mcls = caget(PVs(bpms, 'CK:MCL'))
            mchs = caget(PVs(bpms, 'CK:MCH'))

            AnalyseTimes(location, bpms,
                [mcl + 2**31 * mch
                    for mcl, mch in zip(mcls, mchs)],
                margin = 1)
    
    print '  Restoring event processing'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')


# Temporary workaround: refresh the fast feedback configuration which
# unfortunately gets reset when doing a machine clock synchronisation!
def RefreshFastFeedback(ActiveBpms):
    ActiveBpms = set(ActiveBpms)

    # Assign ids to all BPMs as follows:
    #   In SR assign SR1-1 to SR24-7 ids 1 to 168 in sequence
    #   SR21-8 is assigned 169
    #   Arbitrarily assign numbers to LB+BS
    #   In TS assign ids 1 to 7 in sequence
    Bpms, Ids = zip(*[(bpm, id+1)
        for id, bpm in
            list(enumerate(SR_BPMS)) +
            list(enumerate(LB_BPMS + BS_BPMS)) +
            list(enumerate(TS_BPMS))
        if bpm in ActiveBpms])
    catools.caput(PVs(Bpms, 'FF:BPMID_S'), Ids, timeout = 5)
    caput(PVs(Bpms, 'FF:FRAMELEN_S'), 9000)

    
def RestartFastFeedback(Bpms, triggers):
    print 'Resynchronising Fast Feedback'
    caput(PVs(Bpms, 'FF:STOP_S'), 0)
    triggers.Disable()
    Sleep(3)
    print '  Triggering synchronised start'
    caput(PVs(Bpms, 'FF:START_S'), 0)
    Sleep(3)
    triggers.Enable()
    Sleep(2)
    nodes = caget(PVs(Bpms, 'FF:BPM_COUNT'))
    common_nodes = FindCommonValue(nodes)
    print 'Fast feedback: %s nodes' % common_nodes
    for bpm, n in zip(Bpms, nodes):
        if n != common_nodes:
            print ' ', bpm, n
    

def parseArgs():
    parser = optparse.OptionParser(
        usage = ''''Usage: %prog [flags]
Synchronise Libera BPM clocks

To synchronise machine clocks on all BPMs in the storage ring run
    %prog -Sm
To test machine clock synchronisation on the storage ring run
    %prog -Smt''')

    parser.add_option(
        '-t', dest = 'test_only', action = 'store_true', default = False,
        help = 'Test synchronisation only')
    parser.add_option(
        '-n', dest = 'no_test', action = 'store_true', default = False,
        help = 'Disable synchronisation testing')
    parser.add_option(
        '-s', dest = 'system', action = 'store_true', default = False,
        help = 'Synchronise or test system clocks')
    parser.add_option(
        '-m', dest = 'machine', action = 'store_true', default = False,
        help = 'Synchronise or test machine clocks')
    parser.add_option(
        '-S', dest = 'SR', action = 'store_true', default = False,
        help = 'Synchronise or test storage ring')
    parser.add_option(
        '-I', dest = 'LBS', action = 'store_true', default = False,
        help = 'Synchronise or test injector')
    parser.add_option(
        '-L', dest = 'TS', action = 'store_true', default = False,
        help = 'Synchronise or test lab BPMs')
    parser.add_option(
        '-f', dest = 'SyncFF', action = 'store_true', default = False,
        help = 'Resynchronise Fast Feedback')

    options, arglist = parser.parse_args()
    if arglist:
        parser.error('No arguments supported')

    if not options.SR and not options.LBS and not options.TS:
        parser.error('Specify a region of the machine to synchronise')
    if not options.system and not options.machine and not options.SyncFF:
        parser.error('Specify a class of clock to synchronise')
    if options.TS and (options.SR or options.LBS):
        parser.error('Cannot operate on synchrotron and lab together')

    return options


def main():
    options = parseArgs()

    if options.TS:
        AllBpms = TS_BPMS
        AllEvrs = TS_EVRS
        SystemTrigger = LabSystemTrigger
        MachineTrigger = LabMachineTrigger()
    else:
        AllBpms = []
        AllEvrs = []
        Triggers = [BS_TRIG]
        if options.LBS:
            AllBpms.extend(LB_BPMS + BS_BPMS)
            AllEvrs.extend(LB_EVRS + BS_EVRS)
            Triggers.append(LB_TRIG)
        if options.SR:
            AllBpms.extend(SR_BPMS)
            AllEvrs.extend(SR_EVRS)
        
        SystemTrigger  = GlobalSystemTrigger
        MachineTrigger = GlobalMachineTrigger(Triggers)

    ActiveBpms = GetActiveBpms(AllBpms)
    ActiveEvrs = GetActiveEvrs(AllEvrs)
    SetActiveBpms = set(ActiveBpms)

    FeedbackBpms = GetFeedbackBpms(
        SetActiveBpms & (set(SR_BPMS) | set(TS_BPMS)))
    
    if not options.test_only:
        if options.system:
            SynchroniseSystemClocks(ActiveBpms, ActiveEvrs, SystemTrigger)
        if options.machine:
            SynchroniseMachineClocks(ActiveBpms, MachineTrigger)
            RefreshFastFeedback(FeedbackBpms)

        if not options.no_test:
            print 'Pausing before test'
            Sleep(5.0)
            
    if not options.no_test:
        if options.system:
            CheckSystemClocks(ActiveBpms, ActiveEvrs, SystemTrigger)
        if options.machine:
            CheckMachineClocks(
                SetActiveBpms & set(LB_BPMS),
                SetActiveBpms & set(BS_BPMS),
                SetActiveBpms & set(SR_BPMS),
                SetActiveBpms & set(TS_BPMS),
                ActiveEvrs, SystemTrigger)

    if options.SyncFF:
        RestartFastFeedback(FeedbackBpms, MachineTrigger)
        
    
if __name__ == '__main__':
    main()

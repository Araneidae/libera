#!/dls_sw/prod/tools/RHEL5/bin/dls-python2.6

import sys
import os.path
import optparse
import datetime

from pkg_resources import require
require('cothread==1.17')
from cothread import catools, Sleep



# We have three separate synchronisation groups: LB, BS and TS.

LB_BPMS = \
    ['LB-DI-EBPM-%02d' % (num + 1) for num in range(7)]

BR_BPMS = \
    ['BR%02dC-DI-EBPM-%02d' % (((2*n + 6) // 11) % 4 + 1, n + 1)
        for n in range(22)]

BS_BPMS = \
    ['BS-DI-EBPM-%02d' % (num + 1) for num in range(7)]

SR_BPMS = \
    ['SR%02dC-DI-EBPM-%02d' % (cell + 1, num + 1)
        for cell in range(24) for num in range(7)] + \
    ['SR21C-DI-EBPM-08'] + \
    ['SR%02dS-DI-EBPM-%02d' % (cell, num)
        for cell in [9, 10, 13] for num in [1, 2]]

TS_BPMS = ['TS-DI-EBPM-%02d' % (num + 1) for num in range(8)]

LB_EVRS = \
    ['LI-DI-EVR-01'] + \
    ['BR%02dC-DI-EVR-01' % (num+1) for num in range(4)]

BS_EVRS = \
    ['BS-DI-EVR-01']

SR_EVRS = \
    ['SR%02dC-DI-EVR-01' % (num+1) for num in range(24)]

TS_EVRS = ['TS-DI-EVR-01']

SR_TRIGGER = 'LI-TI-MTGEN-01:SR-DI'
LB_TRIG = 'LI-TI-MTGEN-01:LB-DI-MODE'
BS_TRIG = 'LI-TI-MTGEN-01:BS-DI-MODE'


def PVs(bases, pv):
    return ['%s:%s' % (base, pv) for base in bases]

def caput(pvs, value):
    catools.caput(pvs, value, repeat_value = True, timeout = 5)

def caget(pvs, datatype=None, throw=True, format=catools.FORMAT_RAW):
    return catools.caget(pvs,
        datatype = datatype, timeout = 5, throw = throw, format = format)


def CheckReadbacks(bpms, pv, expected):
    for bpm, s in zip(bpms, caget(PVs(bpms, pv), datatype = type(expected))):
        if s != expected:
            print bpm, s, '-- should be:', expected


def GetActivePVs(iocs, pv):
    enabled_list = caget(PVs(iocs, pv), throw = False)
    result = []
    for ioc, enabled in zip(iocs, enabled_list):
        if enabled.ok:
            result.append(ioc)
        else:
            print ' ', ioc, 'not responding'
    return result

def GetActiveBpms(bpms):
    print 'Checking active BPMs'
    return GetActivePVs(bpms, 'CF:ENABLED_S')

def GetActiveEvrs(evrs):
    print 'Checking active EVRs'
    return GetActivePVs(evrs, 'TRIG:MODE')

# Returns groups of active bpms in each of the three feedback areas: BR, SR, TS.
def GetFeedbackBpms(ActiveBpms):
    print 'Checking BPMs for FF support'
    return [
        GetActivePVs(ActiveBpms & set(group), 'FF:VERSION')
        for group in (BR_BPMS, SR_BPMS, TS_BPMS)]


def GlobalSystemTrigger():
    caput([SR_TRIGGER], 1)
    caput([SR_TRIGGER], 0)

def LabSystemTrigger():
    caput(['TS-DI-EVR-01:TS-RESET.OUT2'], 1)

class GlobalMachineTrigger:
    def __init__(self, triggers):
        self.triggers = triggers
    def Disable(self):
        caput(self.triggers, 'Off')
    def Enable(self):
        caput(self.triggers, 'Every shot')

class LabMachineTrigger:
    def Disable(self):
        caput(['TS-DI-EVR-01:TRIG:MODE'], 'Synchronised')
    def Enable(self):
        caput(['TS-DI-EVR-01:TRIG:MODE'], 'Normal')


def SynchroniseSystemClocks(bpms, evrs, trigger):
    # First put all EVRs into Synchronised mode
    print 'Synchronising system clocks'
    print '  Switching to Synchronised mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    CheckReadbacks(evrs, 'TRIG:MODE', 'Synchronised')
    Sleep(5)

    print '  Enabling SC trigger'
    caput(PVs(bpms, 'CK:SC_SYNC_S'), 0)
    Sleep(2)
    CheckReadbacks(bpms, 'CK:SC_SYNC', 'Waiting Trigger')

    print '  Triggering SC synchronisation'
    trigger()
    Sleep(5)

    print '  Restoring Normal mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')



def SynchroniseMachineClocks(bpms, triggers):
    print 'Synchronising machine clocks'

    # First disable all the triggers.
    print '  Disabling events'
    triggers.Disable()
    Sleep(5)

    print '  Arming MC trigger'
    caput(PVs(bpms, 'CK:MC_SYNC_S'), 0)
    Sleep(5)
    CheckReadbacks(bpms, 'CK:MC_SYNC', 'Waiting Trigger')

    print '  Triggering MC synchronisation'
    triggers.Enable()
    Sleep(2)


def FindCommonValue(values):
    d = {}
    for value in values:
        if value not in d:
            d[value] = 0
        d[value] += 1

    c = 0
    for value, count in d.iteritems():
        if count > c:
            v = value
            c = count
    return v


def AnalyseTimes(location, bpms, times, margin = 0):
    common_time = FindCommonValue(times)
    print '%s:' % location, common_time

    good_bpms = []
    bad_bpms = []
    for bpm, time in zip(bpms, times):
        if abs(time - common_time) > margin:
            print ' ', bpm, time
            bad_bpms.append(bpm)
        else:
            good_bpms.append(bpm)
    return good_bpms, bad_bpms



def CheckSystemClocks(bpms, evrs, trigger):
    print 'Checking system clocks'
    print '  Switching to Synchronised mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    caput(PVs(bpms, 'CK:TIMESTAMP_S'), 'System time')
    Sleep(5)
    print '  Triggering'
    trigger()
    Sleep(3)
    mcls = caget(PVs(bpms, 'CK:MCL'), format = catools.FORMAT_TIME)
    print '  Restoring Normal mode'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')

    good_bpms, bad_bpms = AnalyseTimes(
        'Time', bpms, [
            datetime.datetime.fromtimestamp(mcl.timestamp) for mcl in mcls],
        margin = datetime.timedelta(0))
#     # Put all bad bpms back to NTP time, leave the good ones with system
#     # time.
#     caput(PVs(bad_bpms, 'CK:TIMESTAMP_S'), 'NTP time')
    # Alas we still can't enable System time for timestamps, as SC
    # timestamping remains rather unreliable: so put everything back to NTP
    # time for now.
    caput(PVs(bpms, 'CK:TIMESTAMP_S'), 'NTP time')


def CheckMachineClocks(lb_bpms, bs_bpms, sr_bpms, ts_bpms, evrs, trigger):
    print 'Checking machine clocks'
    print '  Disabling events'
    caput(PVs(evrs, 'TRIG:MODE'), 'Synchronised')
    Sleep(5)
    print '  Triggering'
    trigger()
    Sleep(5)

    for location, bpms in (
            ('LB', lb_bpms), ('BS', bs_bpms), ('SR', sr_bpms),
            ('TS', ts_bpms)):
        if bpms:
            mcls = caget(PVs(bpms, 'CK:MCL'))
            mchs = caget(PVs(bpms, 'CK:MCH'))

            AnalyseTimes(location, bpms,
                [mcl + 2**31 * mch
                    for mcl, mch in zip(mcls, mchs)],
                margin = 1)

    print '  Restoring event processing'
    caput(PVs(evrs, 'TRIG:MODE'), 'Normal')



# The fast feedback BPMs are grouped into three groups for checking, but we
# synchronise them all together.
def RestartFastFeedback(groups, triggers):
    Bpms = [bpm for group in groups for bpm in group]

    print 'Resynchronising Fast Feedback'
    caput(PVs(Bpms, 'FF:STOP_S'), 0)
    triggers.Disable()
    Sleep(3)
    print '  Triggering synchronised start'
    caput(PVs(Bpms, 'FF:START_S'), 0)
    Sleep(3)
    triggers.Enable()
    Sleep(2)

    for name, group in zip(('BR', 'SR', 'TS'), groups):
        if group:
            nodes = caget(PVs(group, 'FF:BPM_COUNT'))
            common_nodes = FindCommonValue(nodes)
            print 'Fast feedback %s: %s nodes' % (name, common_nodes)
            for bpm, n in zip(group, nodes):
                if n != common_nodes:
                    print ' ', bpm, n


def parseArgs():
    parser = optparse.OptionParser(
        usage = ''''Usage: %prog [flags]
Synchronise Libera BPM clocks

To synchronise machine clocks on all BPMs in the storage ring run
    %prog -Sm
To test machine clock synchronisation on the storage ring run
    %prog -Smt''')

    parser.add_option(
        '-t', dest = 'test_only', action = 'store_true', default = False,
        help = 'Test synchronisation only')
    parser.add_option(
        '-n', dest = 'no_test', action = 'store_true', default = False,
        help = 'Disable synchronisation testing')
    parser.add_option(
        '-s', dest = 'system', action = 'store_true', default = False,
        help = 'Synchronise or test system clocks')
    parser.add_option(
        '-m', dest = 'machine', action = 'store_true', default = False,
        help = 'Synchronise or test machine clocks')
    parser.add_option(
        '-S', dest = 'SR', action = 'store_true', default = False,
        help = 'Synchronise or test storage ring')
    parser.add_option(
        '-I', dest = 'LBS', action = 'store_true', default = False,
        help = 'Synchronise or test injector')
    parser.add_option(
        '-L', dest = 'TS', action = 'store_true', default = False,
        help = 'Synchronise or test lab BPMs')
    parser.add_option(
        '-f', dest = 'SyncFF', action = 'store_true', default = False,
        help = 'Resynchronise Fast Feedback')

    options, arglist = parser.parse_args()
    if arglist:
        parser.error('No arguments supported')

    if not options.SR and not options.LBS and not options.TS:
        parser.error('Specify a region of the machine to synchronise')
    if not options.system and not options.machine and not options.SyncFF:
        parser.error('Specify a class of clock to synchronise')
    if options.TS and (options.SR or options.LBS):
        parser.error('Cannot operate on synchrotron and lab together')

    return options


def main():
    options = parseArgs()

    if options.TS:
        AllBpms = TS_BPMS
        AllEvrs = TS_EVRS
        SystemTrigger = LabSystemTrigger
        MachineTrigger = LabMachineTrigger()
    else:
        AllBpms = []
        AllEvrs = []
        Triggers = [BS_TRIG]
        if options.LBS:
            AllBpms.extend(LB_BPMS + BR_BPMS + BS_BPMS)
            AllEvrs.extend(LB_EVRS + BS_EVRS)
            Triggers.append(LB_TRIG)
        if options.SR:
            AllBpms.extend(SR_BPMS)
            AllEvrs.extend(SR_EVRS)

        SystemTrigger  = GlobalSystemTrigger
        MachineTrigger = GlobalMachineTrigger(Triggers)

    ActiveBpms = GetActiveBpms(AllBpms)
    ActiveEvrs = GetActiveEvrs(AllEvrs)
    SetActiveBpms = set(ActiveBpms)

    FeedbackBpms = GetFeedbackBpms(
        SetActiveBpms & (set(BR_BPMS + SR_BPMS + TS_BPMS)))

    if not options.test_only:
        if options.system:
            SynchroniseSystemClocks(ActiveBpms, ActiveEvrs, SystemTrigger)
        if options.machine:
            SynchroniseMachineClocks(ActiveBpms, MachineTrigger)

        if not options.no_test:
            print 'Pausing before test'
            Sleep(5.0)

    if not options.no_test:
        if options.system:
            CheckSystemClocks(ActiveBpms, ActiveEvrs, SystemTrigger)
        if options.machine:
            CheckMachineClocks(
                SetActiveBpms & set(LB_BPMS + BR_BPMS),
                SetActiveBpms & set(BS_BPMS),
                SetActiveBpms & set(SR_BPMS),
                SetActiveBpms & set(TS_BPMS),
                ActiveEvrs, SystemTrigger)

    if options.SyncFF:
        RestartFastFeedback(FeedbackBpms, MachineTrigger)


if __name__ == '__main__':
    main()

/* This file is part of the Libera EPICS Driver,
 * Copyright (C) 2005-2006  Michael Abbott, Diamond Light Source Ltd.
 *
 * The Libera EPICS Driver is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * The Libera EPICS Driver is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * Contact:
 *      Dr. Michael Abbott,
 *      Diamond Light Source Ltd,
 *      Diamond House,
 *      Chilton,
 *      Didcot,
 *      Oxfordshire,
 *      OX11 0DE
 *      michael.abbott@diamond.ac.uk
 */

/* High efficiency support routines. */

#include "support.h"

#include "divide-lookup.h"


/* Here we compute 2^61 / X with 22 bits of precision with a table lookup and
 * a couple of multiplies: this takes around 100ns.  A normalisation factor
 * for X is also returned.
 *
 * This algorithm works by using a table lookup to create a good first
 * approximation to 1/X and then computing a linear correction.  As this
 * correction doubles the number of good bits this is enough!  (We could
 * double the number of bits again with another couple of multiplies, but 22
 * significant bits is ample for our application.)
 *
 * Note first of all that
 *                         2
 *        1               z
 *      ----- = 1 + z + -----
 *      1 - z           1 - z
 *
 * This can be interpreted as showing that (1-z)^-1 is approximated by 1+z
 * with a relative error of z^2.  If z is small enough then z^2 can be very
 * small.
 *
 * We can, by simple bit field extraction, decompose an input x > 0 into two
 * parts a, b such that a >> b, ie b/a is very small.  Then the problem of
 * computing 1/x can be written as:
 * 
 *      1     1     1 (    b)    1  (b)2
 *      - = ----- = - (1 - -) + --- (-)
 *      x   a + b   a (    a)   a+b (a)
 *
 * For convenience write aa = 1/a and c = aa * b, then we have
 * 
 *       -1               2
 *      x   = aa*(1-c) + c /x
 *
 * and so it's clear that if we can compute aa directly (by table lookup)
 * then computing y=aa*(1-aa*b) gives a good approximation with only two
 * multiplications.
 *
 * In the implementation below we use a precomputed table, included as
 * divide-lookup.h and generated by divide-lookup.py.  This defines the
 * number of bits that will be used for fields a and b.
 *
 * For a detailed analysis of the algorithm it is helpful to track both the
 * abstract values (x, a, b, aa, c, y) and their concrete implementations (X,
 * A, B, AA, C, Y, though in fact C and Y are intermediates only below).
 * First of all we normalise x so that it lies in the range 1 <= x < 2: this
 * implies that y ~~ 1/x lies in the range 1/2 < y <= 1 (writing ~~ for
 * "approximately equal").
 *
 * We decompose normalised X into fields A and B of lengths n and m bits
 * respectively (with n+m=31 -- the top bit, always 1, is discarded).  The
 * "true" value of A (used to calculated the initial reciprocal value) is
 * taken as T = (2^n + A + 1/2), and a corresponding 2^(m-1) is subtracted
 * from B.  This ensures that 1/T is as close to 1/X as possible and that T
 * and B are a true decomposition of X = 2^m * T + B.
 *
 * Here are the values used in the computation, both as concrete values (in
 * capitals) and abstract values (lower case).  The symbol M_n represents an
 * n-bit mask, ie M_n = (1<<n)-1.  In the present implementation n=10, m=21.
 * The symbol U(n) or S(n) indicates that the corresponding variable is an
 * n-bit unsigned or signed value, respectively (ie A:U(n) means that
 * 0<=A<2^n and B:S(m) that 2^-(m-1)<=B<2^-(m-1)).
 *
 *      Concrete value          Abstract model          Constraints
 *
 *          +-+-----+-----+          -31
 *      X = |1.  A  |  B  |     x = 2   X               1 <= x < 2
 *          +-+-----+-----+                             X: U(32)
 *          
 *           -m                  
 *      A = 2  X & M_n               -n   
 *           n                  a = 2  T                1 <= a < 2
 *      T = 2  + A + 1/2                                A: U(n), T: U(n+1)
 *      
 *                     m-1           -31                  -n-1          -n-1
 *      B = X & M_m - 2         b = 2   B               -2     <= b <= 2
 *                                                      B: S(m)
 *            31+n                          -31
 *      AA = 2    / T           aa = 1/a = 2   AA       1/2 < aa <= 1
 *                                                      AA: U(32)
 *           -32                            -31                 -n-1
 *      C = 2    AA * 2*B       c = aa b = 2   C        |c| <= 2
 *
 *           -32      31                       -30            31
 *      Y = 2    AA*(2   + C)   y = aa(1+c) = 2   Y ~~ 1/x = 2  /X
 * 
 *           61       61-s                  s
 * Thus Y = 2  / X = 2    / Xin, where X = 2 Xin is the result of normalising
 * the input argument Xin. */

unsigned int Reciprocal(unsigned int X, int &shift)
{
    /* Start by normalising x.  This ensures that we have as many bits as
     * possible (and is required for the rest of the algorithm to work). */
    shift = CLZ(X);
    X <<= shift;

    /* Now extract the two components a and b. */
    unsigned int A = (X & 0x7FFFFFFF) >> M_BITS;
    int B = (X & M_MASK) - B_OFFSET;
    /* Compute the initial estimate by a table lookup. */
    unsigned int AA = DivisionLookup[A];
    /* Perform linear correction. */
    return MulUU(AA, (1<<31) - MulUS(AA, 2*B));
}



/* This routine quickly computes 1e-6 * x without using floating point
 * arithmetic.  This allows us to convert integer nanometre positions to
 * floating point millimetre positions in just over 110ns.
 *
 * The IEEE single precision floating point represents a floating point
 * number with value x as three bit fields
 * 
 *      31 30    23 22              0
 *      +-+--------+-----------------+
 *      |s|    e   |        f        |
 *      +-+--------+-----------------+
 *
 * where
 *                s   e-127           -23
 *        x = (-1) * 2      * (1.0 + 2   f).
 *        
 * Writing F = 2^23 + f this can be conveniently written as
 * 
 *                s   e-150    
 *        x = (-1) * 2      * F.
 *
 * Assembling this value is described step by step below. */

/* Unfortunately, in the current instantiation of the driver, the final step
 * (returning the floating point result) generates the instruction
 *
 *      ldfs    f0, ...
 *
 * to load floating point register f0 with the result.  Unfortunately, this
 * register does not exist!  This adds around 2000ns to the running time. */

float nmTOmm(int nm)
{
    /* K = 2^51 * 1e-6.  This is the largest multiplier that will fit in a 32
     * bit word. */
    unsigned int const K = 0x8637BD05U;
    unsigned int mm;
    if (nm == 0)
        mm = 0;
    else
    {
        unsigned int sign = nm & 0x80000000U;
        if (nm < 0)  nm = -nm;

        /* Normalise the input value to ensure we get as many bits as
         * possible in the fraction. */
        unsigned int Shift = CLZ(nm);
        unsigned int X = nm << Shift;
        /* Compute the unnormalised fraction f.  We now have
         *      F = 2^(19+Shift) * mm
         * where mm = 1e-6 * x is the desired result. */
        unsigned int F = ((unsigned long long) X * K) >> 32;
        /*  At this point we know that f >= 2^30, but we're not sure about the
         * top bit. */
        unsigned int t = CLZ(F);    // Either 0 or 1!
        /* The exponent can now be calculated.  We're going have to shift F
         * down by 8-t (and remove its top bit -- but see below), and so we
         * can calculate that the fraction will satisfy the equation
         *      F' = 2^(t-8)F = 2^(11+Shift+t) mm.
         * We want the assembled result to satisfy the equation
         *      mm = 2^(e-150) F' = 2^(e-150+11+Shift-t) mm
         * and so it's clear that we want e = 139 - Shift - t.
         *     There is one further little hack here: we ought to remove the
         * topmost bit of f before assembling it into the result, but instead
         * we add it into the exponent.  This saves an extra masking operation
         * at the cost of an offset by one in the calculation below (which
         * is, of course, free). */
        unsigned int exp = 139 - Shift - t - 1;
        /* Finally assemble the mm value. */
        mm = sign + (exp << 23) + (F >> (8 - t));
    }

    /* Return the resulting bit pattern as a float. */
    return * (float *) & mm;
}

/* This file is part of the Libera EPICS Driver,
 * Copyright (C) 2005-2006  Michael Abbott, Diamond Light Source Ltd.
 *
 * The Libera EPICS Driver is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * The Libera EPICS Driver is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 * Contact:
 *      Dr. Michael Abbott,
 *      Diamond Light Source Ltd,
 *      Diamond House,
 *      Chilton,
 *      Didcot,
 *      Oxfordshire,
 *      OX11 0DE
 *      michael.abbott@diamond.ac.uk
 */

/* High efficiency support routines. */

#include <limits.h>

#include "support.h"

#include "support-lookup.h"


/* Here we compute 2^61 / X with 22 bits of precision with a table lookup and
 * a couple of multiplies: this takes around 100ns.  A normalisation factor
 * for X is also returned.
 *
 * This algorithm works by using a table lookup to create a good first
 * approximation to 1/X and then computing a linear correction.  As this
 * correction doubles the number of good bits this is enough!  (We could
 * double the number of bits again with another couple of multiplies, but 22
 * significant bits is ample for our application.)
 *
 * Note first of all that
 *                         2
 *        1               z
 *      ----- = 1 + z + -----
 *      1 - z           1 - z
 *
 * This can be interpreted as showing that (1-z)^-1 is approximated by 1+z
 * with a relative error of z^2.  If z is small enough then z^2 can be very
 * small.
 *
 * We can, by simple bit field extraction, decompose an input x > 0 into two
 * parts a, b such that a >> b, ie b/a is very small.  Then the problem of
 * computing 1/x can be written as:
 * 
 *      1     1     1 (    b)    1  (b)2
 *      - = ----- = - (1 - -) + --- (-)
 *      x   a + b   a (    a)   a+b (a)
 *
 * For convenience write aa = 1/a and c = aa * b, then we have
 * 
 *       -1               2
 *      x   = aa*(1-c) + c /x
 *
 * and so it's clear that if we can compute aa directly (by table lookup)
 * then computing y=aa*(1-aa*b) gives a good approximation with only two
 * multiplications.
 *
 * In the implementation below we use a precomputed table, included as
 * divide-lookup.h and generated by divide-lookup.py.  This defines the
 * number of bits that will be used for fields a and b.
 *
 * For a detailed analysis of the algorithm it is helpful to track both the
 * abstract values (x, a, b, aa, c, y) and their concrete implementations (X,
 * A, B, AA, C, Y, though in fact C and Y are intermediates only below).
 * First of all we normalise x so that it lies in the range 1 <= x < 2: this
 * implies that y ~~ 1/x lies in the range 1/2 < y <= 1 (writing ~~ for
 * "approximately equal").
 *
 * We decompose normalised X into fields A and B of lengths n and m bits
 * respectively (with n+m=31 -- the top bit, always 1, is discarded).  The
 * "true" value of A (used to calculated the initial reciprocal value) is
 * taken as T = (2^n + A + 1/2), and a corresponding 2^(m-1) is subtracted
 * from B.  This ensures that 1/T is as close to 1/X as possible and that T
 * and B are a true decomposition of X = 2^m * T + B.
 *
 * Here are the values used in the computation, both as concrete values (in
 * capitals) and abstract values (lower case).  The symbol M_n represents an
 * n-bit mask, ie M_n = (1<<n)-1.  In the present implementation n=10, m=21.
 * The symbol U(n) or S(n) indicates that the corresponding variable is an
 * n-bit unsigned or signed value, respectively (ie A:U(n) means that
 * 0<=A<2^n and B:S(m) that 2^-(m-1)<=B<2^-(m-1)).
 *
 *      Concrete value          Abstract model          Constraints
 *
 *          +-+-----+-----+          -31
 *      X = |1.  A  |  B  |     x = 2   X               1 <= x < 2
 *          +-+-----+-----+                             X: U(32)
 *          
 *           -m                  
 *      A = 2  X & M_n               -n   
 *           n                  a = 2  T                1 <= a < 2
 *      T = 2  + A + 1/2                                A: U(n), T: U(n+1)
 *      
 *                     m-1           -31                  -n-1          -n-1
 *      B = X & M_m - 2         b = 2   B               -2     <= b <= 2
 *                                                      B: S(m)
 *            31+n                          -31
 *      AA = 2    / T           aa = 1/a = 2   AA       1/2 < aa <= 1
 *                                                      AA: U(32)
 *           -32                            -31                 -n-1
 *      C = 2    AA * 2*B       c = aa b = 2   C        |c| <= 2
 *
 *           -32      31                       -30            31
 *      Y = 2    AA*(2   + C)   y = aa(1+c) = 2   Y ~~ 1/x = 2  /X
 * 
 *           61       61-s                  s
 * Thus Y = 2  / X = 2    / Xin, where X = 2 Xin is the result of normalising
 * the input argument Xin.  We also know that Y has between 29 and 30 bits,
 * ie:
 *           61-s
 *          2            29         30       31-s         32-s
 *      Y = ----- ,     2   < Y <= 2  ,     2     <= X < 2    .
 *            X
 */

unsigned int Reciprocal(unsigned int X, int &shift)
{
    /* Start by normalising x.  This ensures that we have as many bits as
     * possible (and is required for the rest of the algorithm to work). */
    int norm = CLZ(X);
    X <<= norm;
    shift += 61 - norm;

    /* Now extract the two components a and b. */
    unsigned int A = (X & 0x7FFFFFFF) >> DIV_M_BITS;
    int B = (X & DIV_M_MASK) - DIV_B_OFFSET;
    /* Compute the initial estimate by a table lookup. */
    unsigned int AA = DivisionLookup[A];
    /* Perform linear correction. */
    return MulUU(AA, (1<<31) - MulUS(AA, 2*B));
}



/* Denormalising, the conversion of a number together with its shift, into a
 * simple integer, is on the face of it as simple as returning X >> shift.
 * However, here we also take overflow into account, which complicates
 * things. */

unsigned int Denormalise(unsigned int X, int shift)
{
    if (shift < 0)
        /* Negative residual shift is a sign of probable trouble: numbers
         * should be arranged so there's some shift left to play with!  Never
         * mind, let's do the best we can... */
        if (CLZ(X) >= (unsigned int) -shift)
            /* Ok, we can afford this much left shift. */
            return X << -shift;
        else
            /* Out of bits.  Return maximum possible value, unless X is zero,
             * in which case we just return 0. */
            if (X == 0)
                return 0;
            else
                return ULONG_MAX;
    else if (shift < 32)
        /* The normal case. */
        return X >> shift;
    else
        /* Shifting by more than 32 is not properly defined, but we know to
         * return 0! */
        return 0;
}



/* Computes logarithm base 2 of input to about 22 bits of precision using
 * table lookup and linear interpolation, as for Reciprocal above.
 *
 * Here the input argument is taken to have 16 bits of fraction and 16 bits
 * of integer: this gives us a sensible output dynamic range, with an output
 * in the range +- 16.
 *
 * Computation proceeds as follows:
 *
 *  1. The input is normalised.  The normalising shift will simply be added
 *     into the final result (and is part of the reason for choosing base 2).
 *  2. The normalised input is separated into three fields, 1, A, B, exactly
 *     as for Reciprocal.
 *  3. The logarithm of A is computed by direct lookup.
 *  4. The remaining offset B is corrected for by linear interpolation.  In
 *     this case the scaling factor for B is also looked up.
 *
 * After normalisation write X = 2^31 x and X is decomposed into
 *
 *           31    m
 *      X = 2   + 2  A + B    (A n bits wide, B m bits wide, n+m=31).
 *
 *                -n                -31      m-1
 * Write a = 1 + 2  (A + 0.5), b = 2   (B - 2   ) and then x = a+b and we
 * compute
 *                                   b                      b
 *      log x = log (a+b) = log (a(1+-)) = log a + log (1 + -)
 *         2       2           2     a        2       2     a
 *                         b
 *            ~~ log a + ------
 *                  2    a ln 2
 *                  
 * The values log_2 a and 1/(a ln 2) are precomputed.  The offsets on A and B
 * used to calculate a and be are used to reduce the maximum value of b to
 * 2^(n+1), thus reducing the residual error. */

int log2(unsigned int X)
{
    /* First need to check for overflow.  Because linear approximation
     * overestimates the logarithm, we can't go all the way to the maximum
     * possible input without overflow.  Also, we have to return something
     * for log2(0), and we might as well return the smallest value (rather
     * than something close to the largest!) */
    if (X >= 0xFFFFFF80)
        return 0x7FFFFFFF;
    else if (X == 0)
        return 0x80000000;
    else
    {
        int shift = CLZ(X);
        X <<= shift;
        unsigned int A = (X & 0x7FFFFFFF) >> LOG2_M_BITS;
        int B = (X & LOG2_M_MASK) - LOG2_B_OFFSET;
        LOG2_LOOKUP Lookup = Log2Lookup[A];
        return ((15 - shift) << 27) + Lookup.Log + MulSS(Lookup.Scale, B);
    }
}



/* Computes exponential to the power 2 to about 22 bits of precising using
 * algorithms similar to those for Reciprocal and log2 above.
 *
 * Here the input argument has 27 bits of fraction and 5 signed bits of
 * integer, yielding 16 bits of fraction and 16 bits of integer.
 *
 * The computation process is very similar to that for log2, but the input
 * does not need normalisation: instead, the integer part of the input is
 * treated separately (as a shift on the final output).
 *
 * The input X = 2^27 x is decomposed into
 *
 *           27     m
 *      X = 2  S + 2 A + B      (A n bits wide, B m bits wide, n+m=27)
 *
 *                   -n                -27      m-1
 * and we write a = 2  (A + 0.5), b = 2   (B - 2   ) and x = S+a+b.  Then
 *
 *       x    S+a+b    S  a  b     S  a
 *      2  = 2      = 2  2  2  ~~ 2  2  (1 + b ln 2)
 *
 *             a      a
 *         = (2  + b 2  ln 2) << S.
 *
 * The constant 2^a is precomputed.  The multiplier 2^a ln 2 could also be
 * precomputed, but in this implementation is multiplied on the fly.
 *
 * The final required shift is returned instead of being applied to the
 * result: this allows accumulation of shifts if required without loss of
 * precision. */

unsigned int exp2(int X, int &shift)
{
    shift += 15 - (X >> 27);
    unsigned int A = (X & 0x07FFFFFF) >> EXP2_M_BITS;
    int B = (X & EXP2_M_MASK) - EXP2_B_OFFSET;
    unsigned int E = Exp2Lookup[A];
    return E + MulSS(B << 6, MulUU(E, EXP2_LN2));
}



/* Returns 1e6 * 20 * log_10(X), used for computing dB values for output to
 * the user.
 *
 * Calculate
 *                                 2e7            2e7     -27
 *      to_dB(X) = 2e7 * log  X = ------ log X = ------ (2   log2(X) + 16)
 *                          10    log 10    2    log 10
 *                                   2              2
 *
 * The two constants, 2^32 * 2^-27 * 2e7 / log_2 10, and 16 * 2e7 / log_2 10,
 * are precomputed by support-header.ph. */

int to_dB(unsigned int X)
{
    return TO_DB_OFFSET + MulSS(log2(X), TO_DB_FACTOR);
}


/* Returns 2^s * 10^(X/(20 * 1e6)), intended as an inverse to to_dB above,
 * where s is a shift normalisation to be applied by the caller.  Calculated
 * as:
 *                                            log 10
 *                      X               X        2
 *                     ---   ( log 10) ---    ------ X
 *                     2e7   (    2  ) 2e7      2e7      KX
 *      from_dB(X) = 10    = (2      )     = 2        = 2
 *
 *                    -s-16      27
 *                 = 2     exp2(2  KX)
 *
 * where
 *          log 10
 *             2
 *      K = ------
 *            2e7
 *
 * We now have to be rather careful about scaling X.  The factor 2^27*K above
 * is about 22.3, which restricts the maximum value of X/1e6 to 93.
 * Furthermore, to avoid losing precision, represent K below as 2^27 * K. */

unsigned int from_dB(int X, int &shift)
{
    /* Check for limits: if computing X<<5 loses bits then we overflow. */
    int XX = X << 5;
    if ((XX >> 5) == X)
    {
        unsigned int result = exp2(MulUS(FROM_DB_FACTOR, XX), shift);
        shift += 16;
        return result;
    }
    else
    {
        /* Oops.  Overflow!  Return a limiting value. */
        if (X > 0)
            shift += 16;
        else
            shift += 48;
        return 0xFFFFFFFF;
    }
}

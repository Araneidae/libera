#!/bin/sh

# This file is part of the Libera EPICS Driver,
# Copyright (C) 2005-2011 Michael Abbott, Diamond Light Source Ltd.
#
# The Libera EPICS Driver is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# The Libera EPICS Driver is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
#
# Contact:
#      Dr. Michael Abbott,
#      Diamond Light Source Ltd,
#      Diamond House,
#      Chilton,
#      Didcot,
#      Oxfordshire,
#      OX11 0DE
#      michael.abbott@diamond.ac.uk

# Startup script for Libera EPICS ioc.  Designed to be called from either
# /etc/init.d/epics or from the runioc script generated by
# install/install-ioc -- both of these set up CONFIGDIR first.
: ${CONFIGDIR:?Do not call this directly!}

# Pick up the Libera and IOC specific configuration parameters.
. $CONFIGDIR/libera
. $CONFIGDIR/epics_ioc


# ----------------------------------------------------------------------------
# Support routines

# Construct IOC parameter string array
#
#   IocParameter <flag> <value>
#
IOC_PARAMETERS=
IocParameter()
{
    IOC_PARAMETERS="$IOC_PARAMETERS $1$2"
}


# ----------------------------------------------------------------------------

# Use the ioc home directory as the startup directory.
cd "$(dirname "$0")"/..
. scripts/epics-functions
BIN_DIR=bin/$EPICS_ARCH


export EPICS_CA_MAX_ARRAY_BYTES=1000000
export DEVICE="$(hostname)"
DEVICE="${DEVICE%%.*}"        # `hostname -s` currently broken!


PIDFILE=/var/run/ioc.pid

# Check for arguments
DAEMON=false
while getopts 'd:nfh' option; do
    case "$option" in
    d)  DEVICE="$OPTARG" ;;
    n)  DAEMON=true  ;;
    f)  rm -f "$PIDFILE" ;;
    h)  cat <<'EOF'
Usage: runioc [options]
    -d <device>:  use supplied device name instead of hostname
    -n            run non-interactive without an IOC shell
    -f            run even if pid file already present
    -h            show this help text
EOF
        exit 0 ;;
    *)  echo >&2 'Invalid option: try -h for help'
        exit 1 ;;
    esac
done
# No extra arguments allowed
if [ $# -ge $OPTIND ]; then
    echo >&2 'Invalid arguments: try -h for help'
    exit 1
fi


# Don't run if the ioc.pid file is present: this is a simple technique to
# prevent us interfering with an already running instance.
if [ -e "$PIDFILE" ]; then
    echo >&2 'PID file found: check epics is not already running'
    exit 1
fi

# If a core dump directory is configured, set this up.
if [ -n "$IOC_CORE" -a -d "$IOC_CORE" ]; then
    ulimit -c unlimited
    echo "$IOC_CORE/core.%h.%t" >/proc/sys/kernel/core_pattern
fi

# Sort out CA logging if required.
if [ $((IOC_CA_LOGGING)) -ne 0 ]; then
    IocParameter -l
    if [ -n "$IOC_BLACKLIST" ]; then
        # If blacklist doesn't begin with / interpret as relative to CONFIGDIR
        [ "${IOC_BLACKLIST::1}" = / ]  ||
            IOC_BLACKLIST="$CONFIGDIR/$IOC_BLACKLIST"
        IocParameter -b "$IOC_BLACKLIST"
    fi
fi


# If running as daemon ensure we're not connected to stdin.
if $DAEMON; then
    IocParameter -n
    exec </dev/null
fi

# Define all the parameters to pass through to the IOC
IocParameter -d "$DEVICE"
IocParameter -cBN= $((IOC_BN_LENGTH))
IocParameter -cTT= $((IOC_TT_LENGTH))
IocParameter -cTW= $((IOC_TT_WINDOW))
IocParameter -cFR= $((IOC_FR_LENGTH))
IocParameter -cSC= $((IOC_SC_LENGTH))
IocParameter -cS0FT= $((IOC_S0_FT))
IocParameter -cS0SA= $((IOC_S0_SA))
# Pass through fundamental ring parameters
IocParameter -cHA= $((HARMONIC))
IocParameter -cLP= $((MCPRESC))
IocParameter -cNT= $((NTBT))

# If requested, disable NTP monitoring.
[ "$IOC_MONITOR_NTP" = 0 ]  &&  IocParameter -N
# If requested, enable rootfs remount on state file writing.
[ "$IOC_REMOUNT_ROOTFS" = 1 ]  &&  IocParameter -M

# Where the IOC should write its pid file
IocParameter -p "$PIDFILE"
# Revolution frequency (used to compute time axis for BN mode)
IocParameter -f $FREV
# Location of persistent state, but only if a path has been defined.
[ -n "$IOC_STATE_PATH" ] && IocParameter -s "$IOC_STATE_PATH/$DEVICE.state"


# Interpret the environment and configuration.
. scripts/compute-options

# Discover the list of temporary filesystems we need to keep an eye on.  We
# use echo to create a space separated list.
export TEMP_FS_LIST="$(echo -n $(
    mount |
    sed -rn '/.* on ([^ ]*) type (tmpfs|ramfs) .*/{s//\1/;p;}'))"


# Finally run the IOC.
echo
echo 'Starting IOC at' $(date)
uname -a
echo System: /lib/ld-*.so /lib/ld-linux.so.*
echo -n 'FPGA: '
$BIN_DIR/monitor -c8 0x14000000
echo Environment:
env
echo 'Running command:'
echo "  $BIN_DIR/ioc $IOC_PARAMETERS"
"$BIN_DIR"/ioc $IOC_PARAMETERS
echo 'IOC stopped at' $(date)
echo


# When we exit make a good effort to clean up any debris.  If we crashed (and
# were unlucky) we may have left lots of threads behind!  Fortunately we
# don't have to mess with this nonsense on newer architectures.
if [ "$ROOTFS_ARCH" = ITECH-v0 -o "$ROOTFS_ARCH" = ITECH-v1 ]; then
    sleep 0.5
    if [ -x /usr/bin/pkill ]; then
        pkill -9 "$BIN_DIR"/ioc
    else
        # No pkill, so do the kill by hand instead.
        DEBRIS="$(ps ho pid -C ioc)"
        if [ -n "$DEBRIS" ]; then
            echo Killing residual ioc processes: $DEBRIS
            sleep 1
            kill -9 $DEBRIS
            DEBRIS="$(ps ho pid -C ioc)"
            [ -n "$DEBRIS" ]  &&
                echo Processes not killed: $DEBRIS
        fi
    fi
fi

# Finally make sure we don't leave the pid file behind!
rm -f "$PIDFILE"
